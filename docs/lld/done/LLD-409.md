# 409 - Fix: Implementation Spec Workflow Context Gaps

## 1. Problem Statement

The implementation spec workflow (N0-N6) has four minor context gaps in how it builds prompts for the spec drafter (N2). None are blocking, but each reduces spec quality:

1. **No CLAUDE.md/README injection** — Project conventions and rules aren't provided to the drafter
2. **Pattern references are line-based** — Head-N truncation may miss relevant code deeper in files
3. **No cross-file dependency analysis** — Files in Section 2.1 are analyzed independently; import chains aren't traced
4. **Prompt truncation drops the middle** — Blunt 40%/30% split loses file excerpts when prompt exceeds 120KB

## 2. Solution Design

### 2.1 Files to Modify

| File | Change | Risk |
|------|--------|------|
| `assemblyzero/workflows/implementation_spec/nodes/generate_spec.py` | Inject project context into prompt; replace truncation strategy | Medium |
| `assemblyzero/workflows/implementation_spec/nodes/analyze_codebase.py` | Add CLAUDE.md/README reading; add import dependency extraction | Low |
| `assemblyzero/workflows/implementation_spec/state.py` | Add `project_context` and `import_dependencies` fields | Low |

### 2.2 Dependencies

- Reuses `assemblyzero/utils/codebase_reader.py` (`read_file_with_budget`, `parse_project_metadata`) from issue #401
- Reuses `assemblyzero/utils/pattern_scanner.py` (`extract_conventions_from_claude_md`) from issue #401

No new external dependencies.

## 3. Gap 1: CLAUDE.md and README Injection

### Current Behavior
N1 (`analyze_codebase.py`) reads target files and finds pattern references, but does not read CLAUDE.md or README.md from the target repo. N2's prompt has no project-level conventions.

### Fix

In `analyze_codebase.py`, after existing file analysis:

```python
from assemblyzero.utils.pattern_scanner import extract_conventions_from_claude_md
from assemblyzero.utils.codebase_reader import parse_project_metadata

# Read CLAUDE.md conventions
claude_md_path = repo_root / "CLAUDE.md"
if claude_md_path.exists():
    conventions = extract_conventions_from_claude_md(
        claude_md_path.read_text(encoding="utf-8", errors="replace")
    )
else:
    conventions = []

# Read README (first 2000 chars for project context)
readme_path = repo_root / "README.md"
readme_summary = ""
if readme_path.exists():
    readme_summary = readme_path.read_text(encoding="utf-8", errors="replace")[:2000]

# Parse project metadata
project_meta = parse_project_metadata(repo_root)
```

Store in state as `project_context: str` — a formatted block injected into N2's prompt between the LLD and file excerpts.

### Prompt Injection Point

In `generate_spec.py` `_build_initial_prompt()`, add after LLD content:

```
## Project Context

{project_context}
```

Budget: ~2KB max for this section.

## 4. Gap 2: AST-Based Pattern Summarization

### Current Behavior
`analyze_codebase.py` uses line-based slicing for pattern references — `content[start_line:end_line]`. If the relevant pattern (e.g., a similar node's implementation) spans lines 150-200, but only lines 1-100 are captured, the spec misses it.

### Fix

Replace head-N line slicing with AST-based summarization for Python files. The `summarize_file_for_context()` function already exists in `assemblyzero/workflows/testing/nodes/implement_code.py` (added in issue #373). Extract it to a shared utility.

In `analyze_codebase.py`, when building pattern excerpts:

```python
from assemblyzero.utils.codebase_reader import read_file_with_budget

# For Python files, use AST summarization
if pattern_path.suffix == ".py":
    excerpt = summarize_python_file(pattern_path, max_chars=3000)
else:
    # Non-Python: keep head-N approach
    excerpt = pattern_path.read_text(encoding="utf-8", errors="replace")[:3000]
```

The AST summarizer extracts: module docstring, class/function signatures with docstrings, and key constants — far more useful than raw first-N lines.

### Shared Utility Location

Move `summarize_file_for_context()` from `implement_code.py` to `assemblyzero/utils/codebase_reader.py` (or keep a thin wrapper that calls it). This avoids circular imports.

## 5. Gap 3: Cross-File Import Dependency Analysis

### Current Behavior
Each file in Section 2.1 (files_to_modify) is analyzed independently. N2 doesn't know that `graph.py` imports from `state.py`, or that `finalize.py` depends on `audit.py`.

### Fix

In `analyze_codebase.py`, after reading each target file, parse its import statements:

```python
import ast

def extract_imports(file_path: Path, repo_root: Path) -> list[str]:
    """Extract intra-project imports from a Python file."""
    try:
        tree = ast.parse(file_path.read_text(encoding="utf-8"))
    except SyntaxError:
        return []

    imports = []
    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom) and node.module:
            # Only track intra-project imports (start with project package name)
            if node.module.startswith("assemblyzero"):
                imports.append(node.module)
    return imports
```

Cross-reference against files_to_modify to produce a dependency summary:

```
## Import Dependencies (files_to_modify)
- generate_spec.py imports: state, analyze_codebase
- analyze_codebase.py imports: state, codebase_reader, pattern_scanner
- state.py imports: (none — leaf node)
```

Store as `import_dependencies: str` in state. Inject into N2's prompt after file excerpts.

Budget: ~500 bytes typical.

## 6. Gap 4: Intelligent Prompt Truncation

### Current Behavior
`_truncate_prompt()` in `generate_spec.py` keeps first 40% + last 30% of the prompt string when it exceeds `MAX_TOTAL_PROMPT_CHARS` (120,000). This drops file excerpts and pattern references from the middle — silently losing critical context.

### Fix

Replace string-slicing truncation with section-aware truncation:

1. Parse the prompt into logical sections (LLD, project context, file excerpts, patterns, template)
2. Assign priority: LLD (must keep) > template (must keep) > file excerpts (high) > patterns (medium) > project context (can trim)
3. When over budget, drop lowest-priority whole sections first, then trim within sections by dropping the longest individual items

```python
def _truncate_prompt_by_sections(prompt: str, max_chars: int = 120_000) -> str:
    """Truncate prompt by dropping lowest-priority sections, not mid-string."""
    if len(prompt) <= max_chars:
        return prompt

    # Split into sections by ## headers
    sections = _split_prompt_sections(prompt)

    # Priority order (highest first)
    priority = ["LLD", "Template", "File Excerpts", "Import Dependencies", "Pattern References", "Project Context"]

    # Drop lowest-priority sections until under budget
    while len("\n".join(s["content"] for s in sections)) > max_chars and sections:
        # Find lowest-priority section
        lowest = max(sections, key=lambda s: priority.index(s["name"]) if s["name"] in priority else len(priority))
        sections.remove(lowest)

    return "\n".join(s["content"] for s in sections)
```

This follows the principle from issue #373: drop whole items, never truncate mid-content.

## 7. State Schema Changes

Add to `assemblyzero/workflows/implementation_spec/state.py`:

```python
class ImplementationSpecState(TypedDict, total=False):
    # ... existing fields ...
    project_context: str        # CLAUDE.md conventions + README summary + metadata
    import_dependencies: str    # Cross-file import map for files_to_modify
```

## 8. Testing Strategy

### Unit Tests (add to `tests/unit/test_implementation_spec_workflow.py`)

| Test | What it verifies |
|------|-----------------|
| `test_analyze_reads_claude_md` | N1 extracts conventions from CLAUDE.md when present |
| `test_analyze_skips_missing_claude_md` | N1 handles missing CLAUDE.md gracefully |
| `test_analyze_extracts_imports` | Import extraction returns intra-project imports only |
| `test_prompt_includes_project_context` | N2 prompt contains project context section |
| `test_prompt_includes_import_deps` | N2 prompt contains import dependencies section |
| `test_truncation_drops_sections_not_midstring` | New truncation drops whole sections by priority |
| `test_truncation_preserves_lld_and_template` | LLD and template survive truncation even at extreme sizes |

### Coverage Target
90% on modified files.

## 9. Risks and Mitigations

| Risk | Mitigation |
|------|-----------|
| CLAUDE.md parsing fails on unusual format | `extract_conventions_from_claude_md` already handles edge cases (#401) |
| AST parsing fails on syntax errors | Fallback to head-N line slicing for files with SyntaxError |
| Import extraction catches external imports | Filter to only `assemblyzero.*` (or detect project package name from pyproject.toml) |
| Section-aware truncation misparses prompt | Add `<!-- SECTION: name -->` markers to prompt template for reliable splitting |

## 10. Implementation Order

1. State schema changes (state.py) — 5 min
2. CLAUDE.md/README injection in N1 (analyze_codebase.py) — 15 min
3. Import dependency extraction in N1 — 10 min
4. Prompt injection in N2 (generate_spec.py) — 10 min
5. Section-aware truncation in N2 — 20 min
6. Tests — 20 min

---

## Review Log

| Field | Value |
|-------|-------|
| Issue | #409 |
| Verdict | APPROVED |
| Date | 2026-02-19 |
| Iterations | 1 |
| Finalized | 2026-02-19T22:00:00Z |

### Review Feedback Summary

LLD written directly by session agent (Opus) — same model the automated workflow would have used. Skipped automated pipeline to conserve API credits.
